%YAML 1.2
---
catalog_schema: {db: {and_or_tier: {bsonType: object, required: [_id, a, b, c], additionalProperties: false,
      properties: {_id: {bsonType: int}, a: {bsonType: bool}, b: {bsonType: bool},
        c: {bsonType: bool}}}, not_and_tier: {bsonType: object, required: [_id, a,
        b], additionalProperties: false, properties: {_id: {bsonType: int}, a: {bsonType: bool},
        b: {anyOf: [bsonType: bool, bsonType: !!str "null"]}}}, mul_add_tier: {bsonType: object,
      required: [_id, a, b, c], additionalProperties: false, properties: {_id: {bsonType: int},
        a: {bsonType: int}, b: {bsonType: int}, c: {bsonType: int}}}, subpath_type_tier: {
      bsonType: object, additionalProperties: true}}}

tests:
  # The expression
  #
  #   a AND b OR c
  #
  # is parsed as
  #
  #   (a AND b) OR c
  #
  # not as
  #
  #   a AND (b OR c)
- description: AND binds tighter than OR
  current_db: db
  query: "SELECT VALUE {'a': a, 'b': b, 'c': c, 'v': a AND b OR c, 'alt': a AND (b
    OR c)} FROM and_or_tier AS coll"
  result_set_schema:
    bsonType: object
    properties:
      _id: {bsonType: objectId}
      '':
        bsonType: object
        properties:
          alt: {bsonType: bool}
          c: {bsonType: bool}
          v: {bsonType: bool}
          b: {bsonType: bool}
          a: {bsonType: bool}
        required: [a, alt, b, c, v]
        additionalProperties: false
    required: ['', _id]
    additionalProperties: false
- description: NOT binds tighter than AND
  current_db: db
  query: "SELECT VALUE {'a': a, 'b': b, 'v': NOT a AND b, 'alt': NOT (a AND b)} FROM
    not_and_tier AS coll"
  result_set_schema:
    bsonType: object
    properties:
      '':
        bsonType: object
        properties:
          a: {bsonType: bool}
          v:
            anyOf:
            - {bsonType: 'null'}
            - {bsonType: bool}
          alt:
            anyOf:
            - {bsonType: 'null'}
            - {bsonType: bool}
          b:
            anyOf:
            - {bsonType: 'null'}
            - {bsonType: bool}
        required: [a, alt, b, v]
        additionalProperties: false
      _id: {bsonType: objectId}
    required: ['', _id]
    additionalProperties: false
- description: IS binds tighter than NOT
  current_db: db
  query: "SELECT VALUE {'a': a, 'v': NOT a IS BOOL, 'alt': (NOT a) IS BOOL} FROM [{'a':
    true}, {'a': null}] AS arr"
  result_set_schema:
    bsonType: object
    properties:
      '':
        bsonType: object
        properties:
          a:
            anyOf:
            - {bsonType: 'null'}
            - {bsonType: bool}
          v: {bsonType: bool}
          alt: {bsonType: bool}
        required: [a, alt, v]
        additionalProperties: false
      _id: {bsonType: objectId}
    required: ['', _id]
    additionalProperties: false
- description: LIKE binds tighter than IS
  current_db: db
  query: "SELECT VALUE {'a': a, 'b': b, 'v': a LIKE b IS NULL} FROM [{'a': 'str',
    'b': 'str'}, {'a': 'str', 'b': null}] AS arr"
  skip_reason: 'SQL-330: Update $like desugarer to work for non-literal patterns'
  result:
  - {'': {a: str, b: str, v: false}}
  - {'': {a: str, b: null, v: true}}

  # The expression
  #
  #   a BETWEEN b AND c IN <tuple>
  #
  # is parsed as
  #
  #   (a BETWEEN b AND c) IN <tuple>
  #
  # not as
  #
  #   a BETWEEN b AND (c IN <tuple>)
  #
  # This test breaks the convention of using "core syntax" in the query field.
  # <expr> IN <tuple> is syntactically rewritten to <expr> = ANY <subquery> in
  # the "core syntax". Here, though, we leave IN in the query intentionally to
  # show precedence behavior.
- description: BETWEEN binds tighter than IN
  current_db: db
  query: "SELECT VALUE {'a': a, 'v': a BETWEEN 0 AND 2 IN (true)} FROM [{'a': 1},
    {'a': 3}] AS arr"
  result_set_schema:
    bsonType: object
    properties:
      _id: {bsonType: objectId}
      '':
        bsonType: object
        properties:
          a: {bsonType: int}
          v: {bsonType: bool}
        required: [a, v]
        additionalProperties: false
    required: ['', _id]
    additionalProperties: false
- description: '|| binds tighter than comparison ops'
  current_db: db
  query: "SELECT VALUE {'a': a, 'b': b, 'c': c, 'v': a || b = c} FROM [{'a': 'a',
    'b': 'b', 'c': 'ab'}] AS arr"
  result_set_schema:
    bsonType: object
    properties:
      '':
        bsonType: object
        properties:
          v: {bsonType: bool}
          b: {bsonType: string}
          c: {bsonType: string}
          a: {bsonType: string}
        required: [a, b, c, v]
        additionalProperties: false
      _id: {bsonType: objectId}
    required: ['', _id]
    additionalProperties: false
- description: mul/div bind tighter than add/sub
  current_db: db
  query: "SELECT VALUE {'a': a, 'b': b, 'c': c, 'v': a * b + c, 'alt': a * (b + c)}
    FROM mul_add_tier AS coll"
  result_set_schema:
    bsonType: object
    properties:
      '':
        bsonType: object
        properties:
          alt: {bsonType: int}
          c: {bsonType: int}
          b: {bsonType: int}
          v: {bsonType: int}
          a: {bsonType: int}
        required: [a, alt, b, c, v]
        additionalProperties: false
      _id: {bsonType: objectId}
    required: ['', _id]
    additionalProperties: false
- description: unary ops bind tighter than mul/div
  current_db: db
  query: "SELECT VALUE {'a': a, 'b': b, 'v': - a * b, 'alt': - (a * b)} FROM [{'a':
    -1, 'b': 1}] AS arr"
  result_set_schema:
    bsonType: object
    properties:
      _id: {bsonType: objectId}
      '':
        bsonType: object
        properties:
          a: {bsonType: int}
          alt: {bsonType: int}
          b: {bsonType: int}
          v: {bsonType: int}
        required: [a, alt, b, v]
        additionalProperties: false
    required: ['', _id]
    additionalProperties: false
- description: subpath op binds tighter than type ops
  current_db: db
  query: "SELECT VALUE {'a': a, 'v': a.b::INT} FROM subpath_type_tier AS coll"
  result_set_schema:
    bsonType: object
    properties:
      _id: {bsonType: objectId}
      '':
        bsonType: object
        properties:
          v: {bsonType: int}
          a:
            bsonType: object
            properties:
              b: {bsonType: bool}
              c: {bsonType: int}
            required: [b, c]
            additionalProperties: false
        required: [a, v]
        additionalProperties: false
    required: ['', _id]
    additionalProperties: false
